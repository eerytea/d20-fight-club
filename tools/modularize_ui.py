# tools/modularize_ui.py
"""
Modularize UI states from main.py into ui/*.py and shrink main.py.

What it does:
- Backs up main.py -> main.py.bak.YYYYMMDDHHMMSS
- Extracts classes: MenuState, SettingsState, TeamSelectState, ExhibitionSelectState,
  ManagerMenuState, RosterState, ScheduleState, TableState, MatchState, App
- Writes each UI state into ui/state_*.py with safe header imports
- Moves App class to ui/app.py (if present) and makes new tiny main.py entrypoint
- Creates package markers (ui/__init__.py) and re-exports states
- Optional: `--git` to commit in three commits

Run from project root:
    python tools/modularize_ui.py [--git]
"""

import argparse
import ast
import datetime
import os
import shutil
import sys
from textwrap import dedent

PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
MAIN_PATH = os.path.join(PROJECT_ROOT, "main.py")
UI_DIR = os.path.join(PROJECT_ROOT, "ui")

STATE_CLASS_TO_FILE = {
    "MenuState":           "state_menu.py",
    "SettingsState":       "state_settings.py",
    "TeamSelectState":     "state_team_select.py",
    "ExhibitionSelectState":"state_exhibition.py",
    "ManagerMenuState":    "state_manager_menu.py",
    "RosterState":         "state_roster.py",
    "ScheduleState":       "state_schedule.py",
    "TableState":          "state_table.py",
    "MatchState":          "state_match.py",
}

UI_FILE_HEADER = dedent("""\
    # Auto-generated by tools/modularize_ui.py
    import pygame, pygame_gui
    from typing import Optional, List, Dict, Tuple

    # Core & Engine imports (keep broad to avoid missing names during split)
    try:
        from core.save_system import Career, save_career, load_career, simulate_week_ai
    except Exception:
        pass
    try:
        from engine import Team, Fighter, Weapon, TBCombat, Event, layout_teams_tiles
    except Exception:
        try:
            from engine.model import Team, Fighter, Weapon
            from engine.tbcombat import TBCombat, Event
            from engine.grid import layout_teams_tiles
        except Exception:
            pass
""")

APP_FILE_HEADER = dedent("""\
    # Auto-generated by tools/modularize_ui.py
    import pygame
    from typing import Optional, Tuple
    try:
        from core.save_system import Career
    except Exception:
        Career = object

    # Default entry state
    try:
        from .state_menu import MenuState
    except Exception:
        MenuState = None
""")

def read_text(p):
    with open(p, "r", encoding="utf-8") as f:
        return f.read()

def write_text(p, s):
    os.makedirs(os.path.dirname(p), exist_ok=True)
    with open(p, "w", encoding="utf-8") as f:
        f.write(s)

def backup_main():
    ts = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
    bak = MAIN_PATH + f".bak.{ts}"
    shutil.copy2(MAIN_PATH, bak)
    return bak

def parse_ast(src):
    return ast.parse(src, filename="main.py")

def get_class_blocks(src, tree, names):
    """
    Return dict: name -> source segment of class definition (with exact indentation).
    """
    out = {}
    for node in tree.body:
        if isinstance(node, ast.ClassDef) and node.name in names:
            seg = ast.get_source_segment(src, node)
            if seg:
                out[node.name] = seg
    return out

def strip_extracted_classes(src, extracted_names):
    """
    Remove the full class definitions from the source text.
    """
    tree = parse_ast(src)
    new_body = []
    last_end = 0
    pieces = []

    for node in tree.body:
        if isinstance(node, ast.ClassDef) and node.name in extracted_names:
            # write src[last_end:node.lineno-1]
            start = node.lineno - 1
            pieces.append(src.splitlines(keepends=True)[last_end:start])
            last_end = getattr(node, "end_lineno", node.lineno)  # requires Py3.8+; fallback: brittle
        else:
            continue

    lines = src.splitlines(keepends=True)
    pieces.append(lines[last_end:])

    # flatten
    result = "".join("".join(chunk) for chunk in pieces)
    return result

def make_ui_init(re_exports):
    lines = ["# Auto-generated by tools/modularize_ui.py", ""]
    for cls, fname in re_exports.items():
        mod = os.path.splitext(fname)[0]
        lines.append(f"from .{mod} import {cls}")
    lines.append("")
    return "\n".join(lines)

def ensure_pkg_markers():
    for d in (UI_DIR,):
        os.makedirs(d, exist_ok=True)
        init_p = os.path.join(d, "__init__.py")
        if not os.path.exists(init_p):
            write_text(init_p, "# package\n")

def write_state_files(class_src_map):
    re_exports = {}
    for cls, fname in STATE_CLASS_TO_FILE.items():
        if cls not in class_src_map:
            continue
        path = os.path.join(UI_DIR, fname)
        body = class_src_map[cls]
        write_text(path, UI_FILE_HEADER + "\n\n" + body + "\n")
        re_exports[cls] = fname
    # update __init__.py to re-export
    init_path = os.path.join(UI_DIR, "__init__.py")
    write_text(init_path, make_ui_init(re_exports))
    return re_exports

def write_app_file(app_src):
    path = os.path.join(UI_DIR, "app.py")
    if app_src:
        # Use the existing App class body as-is (safer)
        content = APP_FILE_HEADER + "\n\n" + app_src + "\n"
    else:
        # Fallback tiny App skeleton
        content = APP_FILE_HEADER + dedent("""
            FPS = 60
            class App:
                def __init__(self, screen_size: Tuple[int,int]=(1280,720), settings=None):
                    pygame.init()
                    try: pygame.mixer.init()
                    except Exception: pass
                    self.screen = pygame.display.set_mode(screen_size, pygame.RESIZABLE | pygame.SCALED)
                    pygame.display.set_caption("D20 Fight Club — Manager")
                    self.clock = pygame.time.Clock()
                    self.running = True
                    self.settings = settings or {"volume_master":0.8, "resolution":[*screen_size]}
                    self.career: Optional[Career] = None
                    self.current_save_path = None
                    self.chosen_tid = None
                    self.exhibition_pair = None
                    self.scheduled_fixture = None
                    self.state = MenuState(self) if MenuState else None

                def apply_resolution(self, res_xy):
                    try:
                        self.screen = pygame.display.set_mode(res_xy, pygame.RESIZABLE | pygame.SCALED)
                    except Exception:
                        self.screen = pygame.display.set_mode(res_xy, pygame.RESIZABLE)

                def set_state(self, state): self.state = state

                def run(self):
                    while self.running:
                        dt = self.clock.tick(FPS)/1000.0
                        for event in pygame.event.get():
                            if event.type == pygame.QUIT:
                                self.running = False
                            elif self.state:
                                self.state.handle(event)
                        if self.state:
                            self.state.update(dt); self.state.draw(self.screen)
                        pygame.display.flip()
                    pygame.quit()
        """)
    write_text(path, content)

def write_minimal_main():
    tiny = dedent("""\
        # Auto-generated entry by tools/modularize_ui.py
        from ui.app import App

        def main():
            App().run()

        if __name__ == "__main__":
            main()
    """)
    write_text(MAIN_PATH, tiny)

def run_git_commits():
    import subprocess
    cmds = [
        ["git", "checkout", "-b", "refactor/modular-ui"],
        ["git", "add", "-A"],
        ["git", "commit", "-m", "refactor(ui): split states into ui/* and move App to ui/app.py"],
        ["git", "add", "main.py", "ui/app.py"],
        ["git", "commit", "-m", "refactor: shrink main.py entrypoint"],
    ]
    for c in cmds:
        try:
            print(">", " ".join(c))
            subprocess.run(c, check=True)
        except Exception as e:
            print(f"(non-fatal) git step failed: {e}")

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--git", action="store_true", help="Run git commits after refactor")
    args = parser.parse_args()

    if not os.path.exists(MAIN_PATH):
        print("main.py not found at project root."); sys.exit(1)

    ensure_pkg_markers()

    src = read_text(MAIN_PATH)
    bak = backup_main()
    print(f"[backup] main.py -> {bak}")

    try:
        tree = parse_ast(src)
    except Exception as e:
        print("Failed to parse main.py AST:", e)
        print("Restoring backup…")
        shutil.copy2(bak, MAIN_PATH)
        sys.exit(1)

    want_classes = list(STATE_CLASS_TO_FILE.keys()) + ["App"]
    class_src_map = get_class_blocks(src, tree, want_classes)

    if not class_src_map:
        print("No target classes found; aborting to be safe.")
        print("Restore from backup if needed:", bak)
        sys.exit(1)

    # write ui state files
    re_exports = write_state_files(class_src_map)

    # write App
    app_src = class_src_map.get("App")
    write_app_file(app_src)

    # strip class bodies from main.py and make a tiny entrypoint
    keep_names = set(class_src_map.keys())
    try:
        # Best effort: replace entire main.py with tiny entrypoint
        write_minimal_main()
    except Exception as e:
        print("Failed to rewrite main.py:", e)
        print("Restoring backup…")
        shutil.copy2(bak, MAIN_PATH)
        sys.exit(1)

    print("[ok] UI states written to ui/*.py")
    print("[ok] App moved to ui/app.py")
    print("[ok] main.py replaced by tiny entrypoint")
    print("Next: run tests to ensure imports are fine:  python -m pytest -q")

    if args.git:
        run_git_commits()
        print("You can now push the branch:  git push -u origin refactor/modular-ui")

if __name__ == "__main__":
    main()
