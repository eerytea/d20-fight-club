# Auto-generated by tools/modularize_ui.py
import pygame, pygame_gui
from typing import Optional, List, Dict, Tuple

# Core & Engine imports (keep broad to avoid missing names during split)
try:
    from core.save_system import Career, save_career, load_career, simulate_week_ai
except Exception:
    pass
try:
    from engine import Team, Fighter, Weapon, TBCombat, Event, layout_teams_tiles
except Exception:
    try:
        from engine.model import Team, Fighter, Weapon
        from engine.tbcombat import TBCombat, Event
        from engine.grid import layout_teams_tiles
    except Exception:
        pass


class MatchState:
    """Watchable match. Sidebar shows live turn log."""
    GRID_W, GRID_H = 18, 12

    def __init__(self, app, scheduled: bool):
        self.app = app
        self.scheduled = scheduled
        self.ui = pygame_gui.UIManager(app.screen.get_size())
        self.font = pygame.font.SysFont(None, 20)
        self.font_big = pygame.font.SysFont(None, 28)
        self._build_ui()

        # Build fighters for this match
        if scheduled:
            fx = self.app.career.get_fixture_for_team(self.app.chosen_tid)
            self.home_tid = fx["home"]; self.away_tid = fx["away"]
        else:
            self.home_tid, self.away_tid = self.app.exhibition_pair

        tH = self.app.career.get_team(self.home_tid)
        tA = self.app.career.get_team(self.away_tid)

        teamA = Team(0, tH["name"], tuple(tH.get("color",[120,180,255])))
        teamB = Team(1, tA["name"], tuple(tA.get("color",[255,140,140])))

        # pick top 4 by OVR for now
        home_fs = sorted(tH["fighters"], key=lambda f: int(f.get("ovr",0)), reverse=True)[:4]
        away_fs = sorted(tA["fighters"], key=lambda f: int(f.get("ovr",0)), reverse=True)[:4]

        fighters = [fighter_from_dict({**fd, "team_id":0}) for fd in home_fs] + \
                   [fighter_from_dict({**fd, "team_id":1}) for fd in away_fs]

        layout_teams_tiles(fighters, self.GRID_W, self.GRID_H)
        self.combat = TBCombat(teamA, teamB, fighters, self.GRID_W, self.GRID_H, seed=int(time.time()) & 0xFFFF)

        # turn stepping
        self.auto = False
        self.auto_timer = 0.0
        self.log_lines: List[str] = []
        self._drain_idx = 0

    def _build_ui(self):
        w,h = self.app.screen.get_size()
        self.btn_back = pygame_gui.elements.UIButton(pygame.Rect(w-16-120, 16, 120, 32),"Back", self.ui)
        self.btn_next = pygame_gui.elements.UIButton(pygame.Rect(w-16-120, 56, 120, 32),"Step Turn", self.ui)
        self.btn_auto = pygame_gui.elements.UIButton(pygame.Rect(w-16-120, 96, 120, 32),"Auto: OFF", self.ui)

    def _push_log(self, text: str):
        self.log_lines.append(text)
        if len(self.log_lines) > 400:
            self.log_lines = self.log_lines[-400:]

    def _drain_events(self):
        evs = self.combat.events
        while self._drain_idx < len(evs):
            e = evs[self._drain_idx]; self._drain_idx += 1
            k = e.kind; p = e.payload
            if k == "init": self._push_log(f"Init: {p.get('name')} (init {p.get('init')})")
            elif k == "round_start": self._push_log(f"— Round {p.get('round')} —")
            elif k == "move_step": self._push_log(f"{p.get('name')} moves to {p.get('to')}")
            elif k == "attack":
                a,d,nat,tac,crit,hit = p.get('attacker'),p.get('defender'),p.get('nat'),p.get('target_ac'),p.get('critical'),p.get('hit')
                if hit: self._push_log(f"{a} attacks {d} (d20={nat} vs AC {tac}) — HIT{' (CRIT!)' if crit else ''}")
                else:   self._push_log(f"{a} attacks {d} (d20={nat} vs AC {tac}) — miss")
            elif k == "damage":
                a,d,amt,hp = p.get('attacker'),p.get('defender'),p.get('amount'),p.get('hp_after')
                self._push_log(f"… {a} deals {amt} to {d} (HP now {hp})")
            elif k == "down":
                self._push_log(f"*** {p.get('name')} is DOWN! ***")
            elif k == "level_up":
                self._push_log(f"↑ {p.get('name')} reached level {p.get('level')}!")
            elif k == "end":
                self._push_log(f"== {p.get('winner') or p.get('reason','Match ended')} ==")

    def handle(self, event):
        if event.type == pygame.VIDEORESIZE:
            self.ui.set_window_resolution(event.size); self._build_ui()

        pressed = (event.type == pygame.USEREVENT and getattr(event, "user_type", None) == pygame_gui.UI_BUTTON_PRESSED) \
                  or (event.type == pygame_gui.UI_BUTTON_PRESSED)
        if pressed:
            if event.ui_element == self.btn_back:
                self.app.set_state(ManagerMenuState(self.app))
            elif event.ui_element == self.btn_next:
                if self.combat.winner is None: self._step_one_turn()
            elif event.ui_element == self.btn_auto:
                self.auto = not self.auto
                self.btn_auto.set_text("Auto: ON" if self.auto else "Auto: OFF")

        self.ui.process_events(event)

    def _step_one_turn(self):
        before = len(self.combat.events)
        self.combat.take_turn()
        if len(self.combat.events) > before:
            self._drain_events()

    def update(self, dt):
        self.ui.update(dt)
        if self.auto and self.combat.winner is None:
            self.auto_timer -= dt
            if self.auto_timer <= 0.0:
                self._step_one_turn()
                self.auto_timer = 0.25

    def draw(self, surf):
        surf.fill((18,18,20))
        # grid area
        grid_w_px = self.app.screen.get_width() - 280
        grid_h_px = self.app.screen.get_height()
        cell_w = grid_w_px // self.GRID_W
        cell_h = grid_h_px // self.GRID_H
        # draw grid
        for gx in range(self.GRID_W):
            for gy in range(self.GRID_H):
                rect = pygame.Rect(gx*cell_w, gy*cell_h, cell_w-1, cell_h-1)
                pygame.draw.rect(surf, (32,34,40), rect, 1)

        # draw fighters
        for f in self.combat.fighters:
            if not getattr(f, "alive", True): col = (100,100,100)
            else:
                col = (255,140,140) if f.team_id==1 else (120,180,255)
            rect = pygame.Rect(f.tx*cell_w+2, f.ty*cell_h+2, cell_w-4, cell_h-4)
            pygame.draw.rect(surf, col, rect)
            name = getattr(f, "name", "?")
            hp = getattr(f, "hp", 0)
            txt = self.font.render(f"{name} ({hp})", True, WHITE)
            surf.blit(txt, (rect.x+4, rect.y+2))

        # sidebar log
        x0 = grid_w_px + 8
        pygame.draw.rect(surf, (28,30,36), pygame.Rect(grid_w_px, 0, 280, self.app.screen.get_height()))
        hdr = self.font_big.render("Turn Log", True, WHITE); surf.blit(hdr, (x0+8, 12))
        y = 44
        for line in self.log_lines[-28:]:
            ln = self.font.render(line, True, WHITE)
            surf.blit(ln, (x0+8, y))
            y += ln.get_height()+2

        self.ui.draw_ui(surf)
